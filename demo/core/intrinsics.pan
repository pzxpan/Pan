package intrinsics;
import mem;
import ptr.drop_in_place;
pub mod pan_intrinsic {
     pub fun atomic_cxchg<T>(dst: T, old: T, src: T) : (T, bool);
     pub fun atomic_cxchg_acq<T>(dst:  T, old: T, src: T) : (T, bool);
     pub fun atomic_cxchg_rel<T>(dst:  T, old: T, src: T) : (T, bool);
     pub fun atomic_cxchg_acqrel<T>(dst: T, old: T, src: T) : (T, bool);
     pub fun atomic_cxchg_relaxed<T>(dst:  T, old: T, src: T) : (T, bool);
     pub fun atomic_cxchg_failrelaxed<T>(dst: T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchg_failacq<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchg_acq_failrelaxed<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchg_acqrel_failrelaxed<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak_acq<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak_rel<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak_acqrel<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak_relaxed<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak_failrelaxed<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak_failacq<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak_acq_failrelaxed<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_cxchgweak_acqrel_failrelaxed<T>(dst:    T, old: T, src: T)  : (T, bool);
     pub fun atomic_load<T>(src:    T)  : T;
     pub fun atomic_load_acq<T>(src:    T)  : T;
     pub fun atomic_load_relaxed<T>(src:    T)  : T;
     pub fun atomic_load_unordered<T>(src:    T)  : T;
     pub fun atomic_store<T>(dst:    T, val: T);
     pub fun atomic_store_rel<T>(dst:    T, val: T);
     pub fun atomic_store_relaxed<T>(dst:    T, val: T);
     pub fun atomic_store_unordered<T>(dst:    T, val: T);
     pub fun atomic_xchg<T>(dst:    T, src: T)  : T;
     pub fun atomic_xchg_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_xchg_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_xchg_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_xchg_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_xadd<T>(dst:    T, src: T)  : T;
     pub fun atomic_xadd_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_xadd_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_xadd_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_xadd_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_xsub<T>(dst:    T, src: T)  : T;
     pub fun atomic_xsub<T>(dst:    T, src: T)  : T;
     pub fun atomic_xsub_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_xsub_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_xsub_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_xsub_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_and<T>(dst:    T, src: T)  : T;
     pub fun atomic_and_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_and_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_and_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_and_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_nand<T>(dst:    T, src: T)  : T;
     pub fun atomic_nand_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_nand_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_nand_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_nand_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_or<T>(dst:    T, src: T)  : T;
     pub fun atomic_or_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_or_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_or_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_or_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_xor<T>(dst:    T, src: T)  : T;
     pub fun atomic_xor_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_xor_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_xor_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_xor_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_max<T>(dst:    T, src: T)  : T;
     pub fun atomic_max_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_max_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_max_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_max_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_min<T>(dst:    T, src: T)  : T;
     pub fun atomic_min_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_min_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_min_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_min_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_umin<T>(dst:    T, src: T)  : T;
     pub fun atomic_umin_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_umin_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_umin_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_umin_relaxed<T>(dst:    T, src: T)  : T;
     pub fun atomic_umax<T>(dst:    T, src: T)  : T;
     pub fun atomic_umax_acq<T>(dst:    T, src: T)  : T;
     pub fun atomic_umax_rel<T>(dst:    T, src: T)  : T;
     pub fun atomic_umax_acqrel<T>(dst:    T, src: T)  : T;
     pub fun atomic_umax_relaxed<T>(dst:    T, src: T)  : T;
     pub fun prefetch_read_data<T>(cdata:    T, locality: i32);
     pub fun prefetch_write_data<T>(cdata:    T, locality: i32);
     pub fun prefetch_read_instruction<T>(cdata:    T, locality: i32);
     pub fun prefetch_write_instruction<T>(cdata:    T, locality: i32);
     pub fun atomic_fence();
     pub fun atomic_fence_acq();
     pub fun atomic_fence_rel();
     pub fun atomic_fence_acqrel();
     pub fun atomic_singlethreadfence();
     pub fun atomic_singlethreadfence_acq();
     pub fun atomic_singlethreadfence_rel();
     pub fun atomic_singlethreadfence_acqrel();
     pub fun abort();
     pub fun unreachable();
     pub fun assume(b: bool);
     pub fun likely(b: bool)  : bool;
     pub fun unlikely(b: bool)  : bool;
     pub fun breakpoint();
     pub fun size_of<T>()  : usize;
     pub fun min_align_of<T>()  : usize;
     pub fun pref_align_of<T>()  : usize;
     pub fun size_of_val<T: Sized>(a:T)  : usize;
     pub fun min_align_of_val<T: Sized>(a:   T)  : usize;
     pub fun type_name<T:  d>()  :    str;
     pub fun type_id<T>()  : u64;
     pub fun panic_if_uninhabited<T>();
     pub fun caller_location(): Location;
     pub fun forget<T>(a: T);
     pub fun transmute<T, U>(e: T)  : U;
     pub fun needs_drop<T>()  : bool;
     pub fun offset<T>(dst:    T, offset: isize)  :    T;
     pub fun arith_offset<T>(dst:    T, offset: isize)  :    T;
     pub fun volatile_copy_nonoverlapping_memory<T>(dst:    T, src:    T, count: usize);
     pub fun volatile_copy_memory<T>(dst:    T, src:    T, count: usize);
     pub fun volatile_set_memory<T>(dst:    T, val: u8, count: usize);
     pub fun volatile_load<T>(src:    T)  : T;
     pub fun volatile_store<T>(dst:    T, val: T);
     pub fun unaligned_volatile_load<T>(src:    T)  : T;
     pub fun unaligned_volatile_store<T>(dst:    T, val: T);
     pub fun sqrtf32(x: f32)  : f32;
     pub fun sqrtf64(x: f64)  : f64;
     pub fun powif32(a: f32, x: i32)  : f32;
     pub fun powif64(a: f64, x: i32)  : f64;
     pub fun sinf32(x: f32)  : f32;
     pub fun sinf64(x: f64)  : f64;
     pub fun cosf32(x: f32)  : f32;
     pub fun cosf64(x: f64)  : f64;
     pub fun powf32(a: f32, x: f32)  : f32;
     pub fun powf64(a: f64, x: f64)  : f64;
     
     pub fun expf32(x: f32)  : f32;
     pub fun expf64(x: f64)  : f64;
     pub fun exp2f32(x: f32)  : f32;
     pub fun exp2f64(x: f64)  : f64;
     pub fun logf32(x: f32)  : f32;
     pub fun logf64(x: f64)  : f64;
     pub fun log10f32(x: f32)  : f32;
     pub fun log10f64(x: f64)  : f64;
     pub fun log2f32(x: f32)  : f32;
     pub fun log2f64(x: f64)  : f64;
     pub fun fmaf32(a: f32, b: f32, c: f32)  : f32;
     pub fun fmaf64(a: f64, b: f64, c: f64)  : f64;
     pub fun fabsf32(x: f32)  : f32;
     pub fun fabsf64(x: f64)  : f64;
     pub fun minnumf32(x: f32, y: f32)  : f32;
     pub fun minnumf64(x: f64, y: f64)  : f64;
     pub fun maxnumf32(x: f32, y: f32)  : f32;
     pub fun maxnumf64(x: f64, y: f64)  : f64;
     pub fun copysignf32(x: f32, y: f32)  : f32;
     pub fun copysignf64(x: f64, y: f64)  : f64;
     pub fun floorf32(x: f32)  : f32;
     pub fun floorf64(x: f64)  : f64;
     pub fun ceilf32(x: f32)  : f32;
     pub fun ceilf64(x: f64)  : f64;
     pub fun truncf32(x: f32)  : f32;
     pub fun truncf64(x: f64)  : f64;
     pub fun rintf32(x: f32)  : f32;
     pub fun rintf64(x: f64)  : f64;
     pub fun nearbyintf32(x: f32)  : f32;
     pub fun nearbyintf64(x: f64)  : f64;
     pub fun roundf32(x: f32)  : f32;
     pub fun roundf64(x: f64)  : f64;
     pub fun fadd_fast<T>(a: T, b: T)  : T;
     pub fun fsub_fast<T>(a: T, b: T)  : T;
     pub fun fmul_fast<T>(a: T, b: T)  : T;
     pub fun fdiv_fast<T>(a: T, b: T)  : T;
     pub fun frem_fast<T>(a: T, b: T)  : T;
     pub fun float_to_int_approx_unchecked<Float, Int>(value: Float)  : Int;
     pub fun ctpop<T>(x: T)  : T;
     pub fun ctlz<T>(x: T)  : T;
     pub fun ctlz_nonzero<T>(x: T)  : T;
     pub fun cttz<T>(x: T)  : T;
     pub fun cttz_nonzero<T>(x: T)  : T;
     pub fun bswap<T>(x: T)  : T;
     pub fun bitreverse<T>(x: T)  : T;
     pub fun add_with_overflow<T>(x: T, y: T)  : (T, bool);
     pub fun sub_with_overflow<T>(x: T, y: T)  : (T, bool);
     pub fun mul_with_overflow<T>(x: T, y: T)  : (T, bool);
     pub fun exact_div<T>(x: T, y: T)  : T;
     pub fun unchecked_div<T>(x: T, y: T)  : T;
     pub fun unchecked_rem<T>(x: T, y: T)  : T;
     pub fun unchecked_shl<T>(x: T, y: T)  : T;
     pub fun unchecked_shr<T>(x: T, y: T)  : T;
     pub fun unchecked_add<T>(x: T, y: T)  : T;
     pub fun unchecked_sub<T>(x: T, y: T)  : T;
     pub fun unchecked_mul<T>(x: T, y: T)  : T;
     pub fun rotate_left<T>(x: T, y: T)  : T;
     pub fun rotate_right<T>(x: T, y: T)  : T;
     pub fun wrapping_add<T>(a: T, b: T)  : T;
     pub fun wrapping_sub<T>(a: T, b: T)  : T;
     pub fun wrapping_mul<T>(a: T, b: T)  : T;
     pub fun saturating_add<T>(a: T, b: T)  : T;
     pub fun saturating_sub<T>(a: T, b: T)  : T;
     pub fun discriminant_value<T>(v:   T)  : u64;
     pub fun try(f: fun(u8)->Any,  cdata: u8, local_ptr: u8)  : i32;
     pub fun nontemporal_store<T>(ptr: T, val: T);
     pub fun ptr_offset_from<T>(ptr: T, base:  T)  : isize;
}

pub fun is_aligned_and_not_null<T>(ptr:    T)  : bool {
    return true;
    //return !ptr.is_null() && ptr as usize;
}

pub fun is_nonoverlapping<T>(src: T, dst: T, count: usize) : bool {
    //let src_usize = src as usize;
    //let dst_usize = dst as usize;
    //let size = size_of(T);
    //let diff = if src_usize > dst_usize : src_usize - dst_usize  else : dst_usize - src_usize ;

   // return diff >= size;
   return true;
}

pub fun copy_nonoverlapping<T>(src: T, dst: T, count: usize) {
    copy_nonoverlapping(src, dst, count);
}

pub fun copy<T>(src: T, dst: T, count: usize) {
    copy(src, dst, count);
}

pub fun write_bytes<T>(dst: T, val: u8, count: usize) {
    write_bytes(dst, val, count);
}
